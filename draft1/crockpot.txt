int	detect_newline(char *str)
{
	int	i;

	i = -1;
	while(str[++i])
	{
		if (str[i] == '\n')
		{
			str[i] = '\0';
			return (1);
		}
	}
	return (0);
}

char	*ft_join(char *path, char *buffer)
{
	int		len;
	char	*ret_str;
	int		i;
	
	len = ft_strlen(path) + ft_strlen(buffer) + 1
	ret_str = (char *)ft_calloc(len, sizeof(char));
	while (*path)
	{
		ret_str[i] = *path;
		i++;
		path++;
	}
	free(path);
	while (*buffer)
	{
		ret_str[i] = *buffer;
		i++;
		buffer++;
	}

}

char	*get_path(int fd, char *which_path)
{
	char	*buffer;
	char	*path;
	int		i;

	buffer = ft_calloc(1025, sizeof(char));
	path = ft_calloc(1, sizeof(char));
	while (!detect_newline(buffer))
	{
		read(fd, buffer, 1024);
		path = ft_join(path, buffer);
		ft_bzero(buffer, 1024);
	}
	free(buffer);
	i = -1
	while (path[++i])
		if (path[i] == '\n')
			path[i] = '\0';
	return(path);
}

// void	exec_command(char **envp, )
// void	init_pipex(int file1, char *arg, char **envp, char * which_path)
// {
// 	int		fd[2];
// 	int		pid;
// 	// char	*path;
// 	// char	**args;

// 	if (pipe(fd) < 0)
// 		pipe_error();
// 	pid = fork();
// 	if (pid < 0)
// 		fork_error();
// 	else if (pid == 0)
// 	{
// 		printf("in the child process \n");
// 		close(fd[0]);
// 		dup2(file1, 0);
// 		dup2(fd[1], 1);
// 	}
// 	else
// 	{
// 		wait(NULL);
// 		printf("in parent process\n");
// 		char buffer[2000];
// 		close(fd[1]);
// 		read(fd[0], buffer, 2000);
// 		printf("%s\n", buffer);
// 		// dupe2(file2, fd[0]); //does this write to file2?
// 		// close(fd[0]);
// 	}
// }

// void	pipex(char *argc)
// {
// 	int	fd[2];
// 	int	pid;

// 	if (pipe(fd) < 0)
// 		pipe_error();
// 	pid = fork();
// 	if (pid < 0)
// 		fork_error();
// 	else if (pid == 0)
// 	{
// 		close(fd[0]);
// 		dupe2(file2, 0);
// 		dupe2(fd[1], 1);
// 		path = find_path(arg1, envp, which_path);
// 		args = ft_split(arg1, ' ');
// 		execve(path, args, envp);
// 	}
// 	else
// 	{
// 		wait(NULL);
// 		close(fd[1]);
// 		dupe2(file2, fd[0]); //does this write to file2?
// 		close(fd[0]);
// 	}
// }

// int main(int argv, char **argc, char **envp)
// {
// 	// int	i;
// 	// if (argc < 5)
// 	// 	arg_error();
// 	// init_pipex(argc[2]);
// 	// i = 3;
// 	// while (i < argv - 2)
// 	// {
// 	// 	pipex(argc[i]);
// 	// 	i++;
// 	// }
// 	(void)argv;
// 	int file1 = open(argc[1], O_RDONLY);
// 	char *which_path = return_which_path(envp);
// 	init_pipex(file1, argc[2], envp, which_path);
	
// 	// char buffer[2000];
// 	// read(fd, buffer, 2000);
// 	// printf("%s\n", buffer);
// }


while (i < m->num_commands)
	{
		//iterate through argc
		//create t_exec node
			//check path
			//check command
		//Current node = node;
		node = (t_exec *)ft_calloc(1, sizeof(t_exec));
		if (!node)
			//free m
			//exit
		node->commands = ft_split(argc[i], ' '); //check ft_split to see if everything gets freed during malloc error and returns NULL
		if (!node->commands)
			//free node;
			//free m and everything inside of m
			//error
		node->path = find_path(m, node->commands[0]);
		if (!node->path)
			//free node->commands
			//free node
			//free m and everything inside of m currently
			//error 
		node->next = NULL;
		if (!curr)
			curr = node;
		else
			curr->next = node;
	}

	char	*find_path(t_mlist *m, char *arg) //char **envp
{
	// int		pid;
	// int		fd[2];
	int		i;
	int		f;
	int		x;
	char	*path;

	// if (pipe(fd) < 0)
	// 	pipex_error(PIPE_ERR, m);
	// pid = fork();
	// if (pid < 0)
	// 	pipex_error(FORK_ERR, m);
	while (m->paths[i])
	{
		path = ft_strjoin_char(m->paths[i], arg, '/');
		f = access(path, F_OK);
		x = access(path, X_OK);
		if (f == 0 && x == 0)
			break;
		else if (f == 0 && x < 0)
			pipex_error(NO_PATH, m);
		free(path);
		i++;
	}
	if (f == 0 && x == 0)
		return (path);
	return (NULL);

	// else if (pid == 0)
	// {
	// 	close(fd[0]);
	// 	if (dup2(fd[1], 1) < 0)
	// 		pipex_error(DUP_ERR, m);
	// 	i = 0;
	// 	while(m->paths[i])
	// 	{
	// 		path = ft_strjoin_char(m->paths[i], arg, '/');
	// 		execve(path, arg, envp);
	// 		free(path);
	// 	}
	// 	pipex_error(EXEC_ERR, m);
	// }
	// else
	// {
	// 	wait(NULL);
	// 	close(fd[1]);
	// 	path = get_path(fd[0]);
	// 	close(fd[0]);
	// }
	// return (path);
}

// char	*get_path(int fd)
// {
// 	int		i;
// 	char	*path;

// 	path = get_next_line(fd);
// 	//if !path
// 		//exit
// 	i = -1;
// 	while(path[++i])
// 		if (path[i] == '\n')
// 			path[i] = '\0';
// 	return (path);
// }